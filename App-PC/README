Ligar robot:
    1- Ligar robot
    2- Fazer calibração inicial.
    3- Verificar ip e subnet mask
    4- Meter em Remote
    5- Ligar servos

Modulo Serie:
    1- Ligar cabo usb ao pc e ao robot
    2- Ir ao gestor de dispositivos e ver a porta COM que o robot está a usar
    3- Inserir porta COM no programa

Modulo Wifi:
    1- Smartphone cria hotspot wifi com nome "test" e senha "123456789"
    2- Escolher ip fixo para o modulo wifi (mesmo q está no esp) e colocá-lo nas definições wifi do pc ()
    3- Porta 11111

Modulo Ethernet:
    1- Ligar cabo ethernet ao pc e ao robot
    2- Mudar o ip do pc nas definições (ip manual) para um no mesmo ip do robot com ultimo nr diferente e mesma netmask
     Ex:"192.168.2.1". (Ver netmask)
    3- Ir ao Cmd dar ping ao ip do robot (para verificar se conectado)
    4- Inserir ip do robot no programa

To-do:

[] Implementar
    ![] - Corrigir o pretende continuar? depois do "q" que aparece 2 vezes.
    ![] - Corrigir o reset da posição que corre x=vorigin antes do getTcppose que vem antes
    ![] - Gravar os movimentos num ficheiro do robô (n gravar todas as posições mas gravar de
     5 em 5 para diminuir o tamanho do ficheiro)
    [] - Ifs
        [] - para escolher programa gravado (se escolhermos fazer mais do que 1)
        [] - para parar e iniciar play (se existir ficheiro)
        ![] - Verifica se está na posição de reset e se já estiver não reseta a posição
        ![] - Verificar os len/fichlen para vir como int e não tuple
    [] - Modulo Gravação
        [] - Implementar vários ficheiros se quisermos (input nome ou caminho que vai entrar na função)
    [] - Redifinir seguranças?

[] Testar
    [] - modulo Wifi
    [] - modulo Gravação
        [] - Verificar ficheiro
    [] - modulo Play
        [] - Verificar tempos
        [] - Verificar play pause
    [] - Ifs
        [X] - para ir para posição inicial
        [] - para para e iniciar play
        [X] - para parar o programa
        [X] - limpar erro
    [] - Se velocidade do robot influencia delay
    [X] - Verificar o shutdown
    [] - Incrementos de rotação
    [X] - Testar seguranças inputs

[] Verificar e Melhorar
    [] Passar para os módulos o mais que conseguir para simplificar o main. (Talvez o calculate position)
    [] - Comentar, "limpar" e documentar (este doc) código
    [] - Calibrar aceleração e desaceleração no programaPrincipal mover para posição inicial

Comentários
- Para não haver delay: Tim send = 20x t sampling do robot 40 para 2 (Teoria: tempo de execução do programa)
- Delay não depende da velocidade do robô!

Notas telemóvel
[] Verificar os events para o inserir teclas que às vezes não funciona
[] Corrigir o reset dar erro.
[] Testar o play
[] Verificar a influencia do time.sleep no play
[] Verificar a necessidade do reset (move by joint qd i=0 (no inicio)) (Vai ser precisa de certeza)
    [] Verificar módulo gravação e play o que gravam e leem. Como voltar à posição inicial? Tirar a posição do ficheirp
    gravação no inicio. Criar outro ficheiro com essa posição e mandar para lá no inicio do ciclo (no fim tbm dá e é mais
    fácil de implementar mas não é tão bom pq pode não estar na posição inicial pretendida. A não ser que no inicio da
    gravação seja sempre a posição de reset e depois é só mandar para lá)? Supostamente já tinhamos verificado q não era
    preciso. Os incrementos bastavam. Isto será pq o que gravamos ser depois do inverse kinematics ou assim? Verificar.
    Se for assim é mt inteligente e isto é desnecessário pq já são posições de juntas.

Events em threds que atualizam g, h, q, p, ...
Opções:
    investigar usos exemplo já feitos (!!!tirar ideia do listener e aplicar com variáveis já usadas!!! acho que á a mais fácil de implementar)
        (só não é a mais rápida mas não por muito. Caso seja preciso mais rápido, meter cada parte a correr em outro thread (ver exemplo))
    meter os keyboars press todos numa função em outro thread e execuatva tudo. Esse thread era chamado no while principal
    meter os keyboars press todos numa função em outro thread e atualizava por ex: if q -> q=1 e no while principal if q ==1 ->... Esse thread era chamado no while principal
